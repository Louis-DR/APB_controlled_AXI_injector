{% from "macros.j2" import apb_register_bank %}

module axi_injector (
  // ┌─────────────────────────────┐
  // │ Control input APB interface │
  // └─────────────────────────────┘
  input          control_pclk,
  input          control_presetn,
  input          control_psel,
  input          control_penable,
  output         control_pready,
  input    [2:0] control_pprot,
  input   [31:0] control_paddr,
  input          control_pwrite,
  input   [31:0] control_pwdata,
  input    [7:0] control_pstrb,
  output  [31:0] control_prdata,
  output         control_pslverr,
  // ┌───────────────────────────┐
  // │ Data output AXI interface │
  // └───────────────────────────┘
  input          data_aclk,
  input          data_aresetn,
  // Write request channel
  output  [23:0] data_awid,
  output  [31:0] data_awaddr,
  output   [7:0] data_awlen,
  output   [2:0] data_awsize,
  output   [1:0] data_awburst,
  output   [2:0] data_awprot,
  output   [3:0] data_awqos,
  output         data_awvalid,
  input          data_awready,
  // Write data channel
  output [255:0] data_wdata,
  output  [31:0] data_wstrb,
  output         data_wlast,
  output         data_wvalid,
  input          data_wready,
  // Write response channel
  input   [23:0] data_bid,
  input    [1:0] data_bresp,
  input          data_bvalid,
  output         data_bready,
  // Read request channel
  output  [23:0] data_arid,
  output  [31:0] data_araddr,
  output   [7:0] data_arlen,
  output   [2:0] data_arsize,
  output   [1:0] data_arburst,
  output   [2:0] data_arprot,
  output   [3:0] data_arqos,
  output         data_arvalid,
  input          data_arready,
  // Read data response channel
  input   [23:0] data_rid,
  input  [255:0] data_rdata,
  input    [1:0] data_rresp,
  input          data_rlast,
  input          data_rvalid,
  output         data_rready
);

logic unused_ok;
assign unused_ok = |{
  control_pprot,
  control_pstrb,
  data_aclk,
  data_aresetn,
  data_awready,
  data_wready,
  data_bid,
  data_bresp,
  data_bvalid,
  data_arready,
  data_rid,
  data_rdata,
  data_rresp,
  data_rlast,
  data_rvalid,
  1'b0
};





/*

  ######                                                ######
  #     # ######  ####  #  ####  ##### ###### #####     #     #   ##   #    # #    #
  #     # #      #    # # #        #   #      #    #    #     #  #  #  ##   # #   #
  ######  #####  #      #  ####    #   #####  #    #    ######  #    # # #  # ####
  #   #   #      #  ### #      #   #   #      #####     #     # ###### #  # # #  #
  #    #  #      #    # # #    #   #   #      #   #     #     # #    # #   ## #   #
  #     # ######  ####  #  ####    #   ###### #    #    ######  #    # #    # #    #

*/

{{apb_register_bank(registers, clock_signal="control_pclk", reset_signal="control_presetn")}}

// Concatenate registers
logic [47:0] start_address__csr;
logic [47:0] stop_address__csr;
logic [47:0] address_increment__csr;
logic [47:0] address_mask__csr;
logic [47:0] number_transactions__csr;
assign start_address__csr        = { start_address_1__csr       , start_address_0__csr       };
assign stop_address__csr         = { stop_address_1__csr        , stop_address_0__csr        };
assign address_increment__csr    = { address_increment_1__csr   , address_increment_0__csr   };
assign address_mask__csr         = { address_mask_1__csr        , address_mask_0__csr        };
assign number_transactions__csr  = { number_transactions_1__csr , number_transactions_0__csr };






/*

   #####                                              #
  #     #  ####  #    # ##### #####   ####  #         #        ####   ####  #  ####
  #       #    # ##   #   #   #    # #    # #         #       #    # #    # # #    #
  #       #    # # #  #   #   #    # #    # #         #       #    # #      # #
  #       #    # #  # #   #   #####  #    # #         #       #    # #  ### # #
  #     # #    # #   ##   #   #   #  #    # #         #       #    # #    # # #    #
   #####   ####  #    #   #   #    #  ####  ######    #######  ####   ####  #  ####

*/

logic do_reset__csr;
logic do_start__csr;
logic do_pause__csr;

assign do_reset__csr = control__csr == 2'h0;
assign do_start__csr = control__csr == 2'h1;
assign do_pause__csr = control__csr == 2'h2;

logic injection_do_reset;
logic injection_do_start;
logic injection_do_pause;

sync do_reset_synchronizer (
  .clock    ( data_aclk          ),
  .resetn   ( data_aresetn       ),
  .data_in  ( do_reset__csr      ),
  .data_out ( injection_do_reset )
);

sync do_start_synchronizer (
  .clock    ( data_aclk          ),
  .resetn   ( data_aresetn       ),
  .data_in  ( do_start__csr      ),
  .data_out ( injection_do_start )
);

sync do_pause_synchronizer (
  .clock    ( data_aclk          ),
  .resetn   ( data_aresetn       ),
  .data_in  ( do_pause__csr      ),
  .data_out ( injection_do_pause )
);

logic injection_is_reset;
logic injection_is_paused;
logic injection_is_active;
logic injection_is_finished;

sync is_reset_synchronizer (
  .clock    ( control_pclk       ),
  .resetn   ( control_presetn    ),
  .data_in  ( injection_do_reset ),
  .data_out ( injection_is_reset )
);

sync is_paused_synchronizer (
  .clock    ( control_pclk        ),
  .resetn   ( control_presetn     ),
  .data_in  ( injection_do_pause  ),
  .data_out ( injection_is_paused )
);

sync is_active_synchronizer (
  .clock    ( control_pclk        ),
  .resetn   ( control_presetn     ),
  .data_in  ( injection_enable    ),
  .data_out ( injection_is_active )
);

sync is_finished_synchronizer (
  .clock    ( control_pclk          ),
  .resetn   ( control_presetn       ),
  .data_in  ( injection_finished    ),
  .data_out ( injection_is_finished )
);

enum {
  RESET    = STATUS__INJECTION__IS_RESET,
  PAUSED   = STATUS__INJECTION__IS_PAUSED,
  ACTIVE   = STATUS__INJECTION__IS_ACTIVE,
  FINISHED = STATUS__INJECTION__IS_FINISHED
} status_fsm_state, status_fsm_state_next;

always_comb begin
  status_fsm_state_next = status_fsm_state;
  case (status_fsm_state)
    RESET    : if      (injection_is_active)   status_fsm_state_next = ACTIVE;
    PAUSED   : if      (injection_is_reset)    status_fsm_state_next = RESET;
               else if (injection_is_active)   status_fsm_state_next = ACTIVE;
    ACTIVE   : if      (injection_is_reset)    status_fsm_state_next = RESET;
               else if (injection_is_paused)   status_fsm_state_next = PAUSED;
               else if (injection_is_finished) status_fsm_state_next = FINISHED;
    FINISHED : if      (injection_is_reset)    status_fsm_state_next = RESET;
  endcase
end

always_ff @(posedge control_pclk or negedge control_presetn) begin
  if (!control_presetn) status_fsm_state <= RESET;
  else                  status_fsm_state <= status_fsm_state_next;
end

assign status__hw_write_enable            = 1'b0;
assign status__injection__hw_write_enable = (status_fsm_state_next != status_fsm_state);
assign status__injection__hw_write_data   = status_fsm_state_next;

logic injection_enable;

logic injection_back_pressure;
logic injection_finished;

always_ff @(posedge data_aclk or negedge data_aresetn) begin
  if (!data_aresetn) begin
    injection_enable <= 1'd0;
  end else begin
    if (injection_do_pause || injection_back_pressure || injection_finished) begin
      injection_enable <= 1'b0;
    end else if (injection_do_start) begin
      injection_enable <= 1'b1;
    end
  end
end






/*

     #                                                  #####
    # #   #####  #####  #####  ######  ####   ####     #     # ###### #    # ###### #####    ##   ##### #  ####  #    #
   #   #  #    # #    # #    # #      #      #         #       #      ##   # #      #    #  #  #    #   # #    # ##   #
  #     # #    # #    # #    # #####   ####   ####     #  #### #####  # #  # #####  #    # #    #   #   # #    # # #  #
  ####### #    # #    # #####  #           #      #    #     # #      #  # # #      #####  ######   #   # #    # #  # #
  #     # #    # #    # #   #  #      #    # #    #    #     # #      #   ## #      #   #  #    #   #   # #    # #   ##
  #     # #####  #####  #    # ######  ####   ####      #####  ###### #    # ###### #    # #    #   #   #  ####  #    #

*/

logic [48:0] injection_address; // Extra bit for overflow
logic [47:0] injection_countdown;

always_ff @(posedge data_aclk or negedge data_aresetn) begin
  if (!data_aresetn) begin
    // Hardware reset
    injection_address   <= 48'd0;
    injection_countdown <= 48'd0;
  end else if (injection_do_reset) begin
    // Software reset
    injection_address   <= start_address__csr;
    injection_countdown <= number_transactions__csr;
  end else begin
    if (injection_enable == 1'b1) begin
      if (injection_mode__csr == 1'b0) begin
        // Inject a number of transactions
        injection_countdown <= injection_countdown - 1;
      end else begin
        // Inject in an address range
        injection_address <= injection_address + address_increment__csr;
      end
    end
  end
end

assign injection_finished = injection_mode__csr ? (injection_address >= stop_address__csr)
                                                : (injection_countdown == 1'b0);





/*

  ###
   #  #    #      # ######  ####  ##### #  ####  #    #
   #  ##   #      # #      #    #   #   # #    # ##   #
   #  # #  #      # #####  #        #   # #    # # #  #
   #  #  # #      # #      #        #   # #    # #  # #
   #  #   ## #    # #      #    #   #   # #    # #   ##
  ### #    #  ####  ######  ####    #   #  ####  #    #

*/

// Write request channel
logic  [23:0] injection__data_awid;
logic  [31:0] injection__data_awaddr;
logic   [7:0] injection__data_awlen;
logic   [2:0] injection__data_awsize;
logic   [1:0] injection__data_awburst;
logic   [2:0] injection__data_awprot;
logic   [3:0] injection__data_awqos;
logic         injection__data_awvalid;
// Write data channel
logic [255:0] injection__data_wdata;
logic  [31:0] injection__data_wstrb;
logic         injection__data_wlast;
logic         injection__data_wvalid;
// Write response channel
logic         injection__data_bready;
// Read request channel
logic  [23:0] injection__data_arid;
logic  [31:0] injection__data_araddr;
logic   [7:0] injection__data_arlen;
logic   [2:0] injection__data_arsize;
logic   [1:0] injection__data_arburst;
logic   [2:0] injection__data_arprot;
logic   [3:0] injection__data_arqos;
logic         injection__data_arvalid;
// Read data response channel
logic         injection__data_rready;

logic [23:0] injection_counter;
logic [23:0] injection_counter_next;

logic [8:0] injection_write_burst_counter;
logic [8:0] injection_write_burst_counter_next;

always_comb begin
  injection_back_pressure =   1'b0;
  injection__data_arid    =  24'd0;
  injection__data_araddr  =  48'd0;
  injection__data_arlen   =   8'd0;
  injection__data_arsize  =   3'd0;
  injection__data_arburst =   2'd0;
  injection__data_arprot  =   3'd0;
  injection__data_arqos   =   4'd0;
  injection__data_arvalid =   1'b0;
  injection__data_awid    =  24'd0;
  injection__data_awaddr  =  48'd0;
  injection__data_awlen   =   8'd0;
  injection__data_awsize  =   3'd0;
  injection__data_awburst =   2'd0;
  injection__data_awprot  =   3'd0;
  injection__data_awqos   =   4'd0;
  injection__data_awvalid =   1'b0;
  injection__data_wdata   = 256'd0;
  injection__data_wstrb   =  32'd0;
  injection__data_wlast   =   1'b0;
  injection__data_wvalid  =   1'b0;
  injection__data_rready  =   1'b1;
  injection__data_bready  =   1'b1;
  injection_counter_next  = injection_counter;
  injection_write_burst_counter_next = injection_write_burst_counter;
  if (transaction_type__direction__csr == TRANSACTION_TYPE__DIRECTION__READ) begin
    // Read injection
    if (injection_enable) begin
      injection__data_arid    = injection_counter_next;
      injection__data_araddr  = injection_address;
      injection__data_arlen   = transaction_type__length__csr;
      injection__data_arsize  = transaction_type__size__csr;
      injection__data_arburst = transaction_type__burst__csr;
      injection__data_arprot  = transaction_type__protection__csr;
      injection__data_arqos   = transaction_type__quality_of_service__csr;
      injection__data_arvalid = 1'b1;
      if (data_arready == 1'b1) injection_counter_next = injection_counter + 1;
      else injection_back_pressure = 1'b1;
    end else injection__data_arvalid = 1'b0;
  end else begin
    injection__data_arvalid = 1'b0;
    // Write injection
    if (injection_write_burst_counter == 0) begin
      // Set burst counter
      injection_write_burst_counter_next = {1'b0,transaction_type__burst__csr} + 1;
      injection__data_awid    = injection_counter_next;
      injection__data_awaddr  = injection_address;
      injection__data_awlen   = transaction_type__length__csr;
      injection__data_awsize  = transaction_type__size__csr;
      injection__data_awburst = transaction_type__burst__csr;
      injection__data_awprot  = transaction_type__protection__csr;
      injection__data_awqos   = transaction_type__quality_of_service__csr;
      injection__data_awvalid = 1'b1;
      if (data_awready == 1'b1) injection_counter_next = injection_counter + 1;
      else injection_back_pressure = 1'b1;
    end
    // Test again the burst counter to allow AW and W at the same time for the first beat
    if (injection_write_burst_counter_next > 0) begin
      // Only decrement the burst counter if the W beat was accepter
      if (data_wready == 1'b1) injection_write_burst_counter_next = injection_write_burst_counter - 1;
      injection__data_wdata  = 256'hFEDCBA9876543210FEDCBA9876543210FEDCBA9876543210FEDCBA9876543210;
      injection__data_wstrb  = 32'hFFFFFFFF;
      injection__data_wlast  = injection_write_burst_counter_next == 0;
      injection__data_wvalid = 1'b1;
    end
  end
end

always_ff @(posedge data_aclk or negedge data_aresetn) begin
  if (!data_aresetn) begin
    injection_counter             <= 24'd0;
    injection_write_burst_counter <=  9'd0;
  end else begin
    injection_counter             <= injection_counter_next;
    injection_write_burst_counter <= injection_write_burst_counter_next;
  end
end

// Write request channel
assign data_awid    = injection__data_awid;
assign data_awaddr  = injection__data_awaddr;
assign data_awlen   = injection__data_awlen;
assign data_awsize  = injection__data_awsize;
assign data_awburst = injection__data_awburst;
assign data_awprot  = injection__data_awprot;
assign data_awqos   = injection__data_awqos;
assign data_awvalid = injection__data_awvalid;
// Write data channel
assign data_wdata   = injection__data_wdata;
assign data_wstrb   = injection__data_wstrb;
assign data_wlast   = injection__data_wlast;
assign data_wvalid  = injection__data_wvalid;
// Write response channel
assign data_bready  = injection__data_bready;
// Read request channel
assign data_arid    = injection__data_arid;
assign data_araddr  = injection__data_araddr;
assign data_arlen   = injection__data_arlen;
assign data_arsize  = injection__data_arsize;
assign data_arburst = injection__data_arburst;
assign data_arprot  = injection__data_arprot;
assign data_arqos   = injection__data_arqos;
assign data_arvalid = injection__data_arvalid;
// Read data response channel
assign data_rready  = injection__data_rready;


endmodule
